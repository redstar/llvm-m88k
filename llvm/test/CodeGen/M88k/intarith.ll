; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; Test floating point arithmetic.
;
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 -m88k-enable-delay-slot-filler=false | FileCheck --check-prefixes=CHECK,MC88100 %s
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 -m88k-enable-delay-slot-filler=false | FileCheck --check-prefixes=CHECK,MC88110 %s

define i64 @udiv64(i64 %a, i64 %b) {
; CHECK-LABEL: udiv64:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; CHECK-NEXT:    or %r14, %r0, %r1
; CHECK-NEXT:    bsr __udivdi3
; CHECK-NEXT:    or %r1, %r0, %r14
; CHECK-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %quot = udiv i64 %a, %b
  ret i64 %quot
}

define i64 @udiv64with32(i64 %a, i32 %b) {
; MC88100-LABEL: udiv64with32:
; MC88100:       | %bb.0:
; MC88100-NEXT:    subu %r31, %r31, 16
; MC88100-NEXT:    st %r30, %r31, 0
; MC88100-NEXT:    addu %r30, %r31, 0
; MC88100-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; MC88100-NEXT:    or %r14, %r0, %r1
; MC88100-NEXT:    or %r1, %r0, 0
; MC88100-NEXT:    or %r5, %r0, %r4
; MC88100-NEXT:    or %r4, %r0, %r1
; MC88100-NEXT:    bsr __udivdi3
; MC88100-NEXT:    or %r1, %r0, %r14
; MC88100-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; MC88100-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; MC88100-NEXT:    addu %r31, %r31, 16
; MC88100-NEXT:    jmp %r1
;
; MC88110-LABEL: udiv64with32:
; MC88110:       | %bb.0:
; MC88110-NEXT:    | kill: def $r3 killed $r3 killed $r2_r3 def $r2_r3
; MC88110-NEXT:    | kill: def $r2 killed $r2 killed $r2_r3 def $r2_r3
; MC88110-NEXT:    divu.d %r2, %r2, %r4
; MC88110-NEXT:    jmp %r1
  %conv = zext i32 %b to i64
  %quot = udiv i64 %a, %conv
  ret i64 %quot
}

define i64 @sdiv64(i64 %a, i64 %b) {
; CHECK-LABEL: sdiv64:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; CHECK-NEXT:    or %r14, %r0, %r1
; CHECK-NEXT:    bsr __divdi3
; CHECK-NEXT:    or %r1, %r0, %r14
; CHECK-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %quot = sdiv i64 %a, %b
  ret i64 %quot
}

define i64 @urem64(i64 %a, i64 %b) {
; CHECK-LABEL: urem64:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; CHECK-NEXT:    or %r14, %r0, %r1
; CHECK-NEXT:    bsr __umoddi3
; CHECK-NEXT:    or %r1, %r0, %r14
; CHECK-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %quot = urem i64 %a, %b
  ret i64 %quot
}

define i64 @srem64(i64 %a, i64 %b) {
; CHECK-LABEL: srem64:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; CHECK-NEXT:    or %r14, %r0, %r1
; CHECK-NEXT:    bsr __moddi3
; CHECK-NEXT:    or %r1, %r0, %r14
; CHECK-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %quot = srem i64 %a, %b
  ret i64 %quot
}

define i64 @mul64(i64 %a, i64 %b) {
; CHECK-LABEL: mul64:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; CHECK-NEXT:    or %r14, %r0, %r1
; CHECK-NEXT:    bsr __muldi3
; CHECK-NEXT:    or %r1, %r0, %r14
; CHECK-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %mult = mul i64 %a, %b
  ret i64 %mult
}

define i64 @mul32to64(i32 %a, i32 %b) {
; MC88100-LABEL: mul32to64:
; MC88100:       | %bb.0:
; MC88100-NEXT:    subu %r31, %r31, 16
; MC88100-NEXT:    st %r30, %r31, 0
; MC88100-NEXT:    addu %r30, %r31, 0
; MC88100-NEXT:    st %r14, %r30, 4 | 4-byte Folded Spill
; MC88100-NEXT:    or %r14, %r0, %r1
; MC88100-NEXT:    or %r5, %r0, %r3
; MC88100-NEXT:    or %r1, %r0, 0
; MC88100-NEXT:    or %r4, %r0, 0
; MC88100-NEXT:    or %r3, %r0, %r2
; MC88100-NEXT:    or %r2, %r0, %r1
; MC88100-NEXT:    bsr __muldi3
; MC88100-NEXT:    or %r1, %r0, %r14
; MC88100-NEXT:    ld %r14, %r30, 4 | 4-byte Folded Reload
; MC88100-NEXT:    ld %r30, %r30, 0 | 4-byte Folded Reload
; MC88100-NEXT:    addu %r31, %r31, 16
; MC88100-NEXT:    jmp %r1
;
; MC88110-LABEL: mul32to64:
; MC88110:       | %bb.0:
; MC88110-NEXT:    mulu.d %r2, %r2, %r3
; MC88110-NEXT:    jmp %r1
  %conva = zext i32 %a to i64
  %convb = zext i32 %b to i64
  %mult = mul i64 %conva, %convb
  ret i64 %mult
}
