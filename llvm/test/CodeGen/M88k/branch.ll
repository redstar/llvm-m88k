; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
;
; Test generation of branches.
;
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 -O0 -m88k-enable-delay-slot-filler=false -verify-machineinstrs | FileCheck %s
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 -O0 -m88k-enable-delay-slot-filler=false -verify-machineinstrs | FileCheck %s

; Unconditional loop.
; TODO This triggers an assertion, because register $r2 is used inside the loop
;      but the register is not life.
;define void @f1(ptr %dest) {
;  br label %loop
;loop:
;  store volatile i8 1, ptr %dest
;  br label %loop
;}

; Test indirect jumps.
; Without -O0, the function is turned into a leaf function, and the branches
; are transformed into return instructions.
define i32 @f2(i32 %x, i32 %y, i32 %op) {
; CHECK-LABEL: f2:
; CHECK:       | %bb.0: | %entry
; CHECK-NEXT:    subu %r31, %r31, 24
; CHECK-NEXT:    st %r1, %r31, 4
; CHECK-NEXT:    st %r1, %r31, 44 | 4-byte Folded Spill
; CHECK-NEXT:    st %r2, %r31, 40 | 4-byte Folded Spill
; CHECK-NEXT:    or %r2, %r0, %r3
; CHECK-NEXT:    ld %r3, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    st %r2, %r31, 36 | 4-byte Folded Spill
; CHECK-NEXT:    subu %r2, %r4, 1
; CHECK-NEXT:    st %r2, %r31, 32 | 4-byte Folded Spill
; CHECK-NEXT:    cmp %r2, %r2, 5
; CHECK-NEXT:    st %r3, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    bb1 8, %r2, .LBB0_8
; CHECK-NEXT:  | %bb.1: | %entry
; CHECK-NEXT:    ld %r3, %r31, 32 | 4-byte Folded Reload
; CHECK-NEXT:    or.u %r2, %r0, %hi16(.LJTI0_0)
; CHECK-NEXT:    or %r2, %r2, %lo16(.LJTI0_0)
; CHECK-NEXT:    ld %r2, %r2[%r3]
; CHECK-NEXT:    jmp %r2
; CHECK-NEXT:  .LBB0_2: | %b.add
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_3: | %b.sub
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    subu %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_4: | %b.and
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    and %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_5: | %b.or
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    or %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_6: | %b.xor
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    xor %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_7: | %b.mul
; CHECK-NEXT:    ld %r2, %r31, 40 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r3, %r31, 36 | 4-byte Folded Reload
; CHECK-NEXT:    mulu %r2, %r2, %r3
; CHECK-NEXT:    st %r2, %r31, 28 | 4-byte Folded Spill
; CHECK-NEXT:    br .LBB0_8
; CHECK-NEXT:  .LBB0_8: | %exit
; CHECK-NEXT:    ld %r1, %r31, 44 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r2, %r31, 28 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r1, %r31, 24 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 24
; CHECK-NEXT:    jmp %r1
entry:
  switch i32 %op, label %exit [
    i32 1, label %b.add
    i32 2, label %b.sub
    i32 3, label %b.and
    i32 4, label %b.or
    i32 5, label %b.xor
    i32 6, label %b.mul
  ]

b.add:
  %add = add i32 %x, %y
  br label %exit

b.sub:
  %sub = sub i32 %x, %y
  br label %exit

b.and:
  %and = and i32 %x, %y
  br label %exit

b.or:
  %or = or i32 %x, %y
  br label %exit

b.xor:
  %xor = xor i32 %x, %y
  br label %exit

b.mul:
  %mul = mul i32 %x, %y
  br label %exit

exit:
  %res = phi i32 [ %x,   %entry ],
                 [ %add, %b.add ],
                 [ %sub, %b.sub ],
                 [ %and, %b.and ],
                 [ %or,  %b.or ],
                 [ %xor, %b.xor ],
                 [ %mul, %b.mul ]
  ret i32 %res
}

; Test indirect call.
define i32 @f3(ptr %f) {
; CHECK-LABEL: f3:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r1, %r31, 4
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r1, %r30, 8 | 4-byte Folded Spill
; CHECK-NEXT:    jsr %r2
; CHECK-NEXT:    ld %r1, %r30, 8 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r1, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %call = call i32 %f()
  ret i32 %call
}

; Test indirect tail call.
; TODO Tail calls are not yet handled. The IR should be translated to
;      jmp %r1
define i32 @f4(ptr %f) {
; CHECK-LABEL: f4:
; CHECK:       | %bb.0:
; CHECK-NEXT:    subu %r31, %r31, 16
; CHECK-NEXT:    st %r1, %r31, 4
; CHECK-NEXT:    st %r30, %r31, 0
; CHECK-NEXT:    addu %r30, %r31, 0
; CHECK-NEXT:    st %r1, %r30, 8 | 4-byte Folded Spill
; CHECK-NEXT:    jsr %r2
; CHECK-NEXT:    ld %r1, %r30, 8 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r30, %r30, 4 | 4-byte Folded Reload
; CHECK-NEXT:    ld %r1, %r30, 0 | 4-byte Folded Reload
; CHECK-NEXT:    addu %r31, %r31, 16
; CHECK-NEXT:    jmp %r1
  %call = tail call i32 %f()
  ret i32 %call
}
