; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; Test argument passing and stack frame construction, callee side.
;
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 -verify-machineinstrs -m88k-enable-delay-slot-filler=false | FileCheck %s
; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 -verify-machineinstrs -m88k-enable-delay-slot-filler=false | FileCheck %s

; Registers r2 to r9 used, no parameter passed on stack.
define i32 @f1(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h) {
; CHECK-LABEL: f1:
; CHECK:       | %bb.0:
; CHECK-NEXT:    and %r2, %r2, %r3
; CHECK-NEXT:    and %r2, %r4, %r2
; CHECK-NEXT:    and %r2, %r5, %r2
; CHECK-NEXT:    and %r2, %r6, %r2
; CHECK-NEXT:    and %r2, %r7, %r2
; CHECK-NEXT:    and %r2, %r8, %r2
; CHECK-NEXT:    and %r2, %r9, %r2
; CHECK-NEXT:    jmp %r1
  %sum1 = and i32 %a, %b
  %sum2 = and i32 %c, %sum1
  %sum3 = and i32 %d, %sum2
  %sum4 = and i32 %e, %sum3
  %sum5 = and i32 %f, %sum4
  %sum6 = and i32 %g, %sum5
  %sum7 = and i32 %h, %sum6
  ret i32 %sum7
}

; Registers r2 to r9 used, 2 parameter passed on stack.
define i32 @f2(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %a, i32 %b) {
; CHECK-LABEL: f2:
; CHECK:       | %bb.0:
; CHECK-NEXT:    ld %r2, %r31, 0
; CHECK-NEXT:    ld %r3, %r31, 4
; CHECK-NEXT:    or %r2, %r2, %r3
; CHECK-NEXT:    jmp %r1
  %sum = or i32 %a, %b
  ret i32 %sum
}

; Registers r2 to r9 used, 2 parameter passed on stack.
define i64 @f3(i64 %0, i64 %1, i64 %2, i64 %3, i64 %a, i64 %b) {
; CHECK-LABEL: f3:
; CHECK:       | %bb.0:
; CHECK-NEXT:    ld.d %r4, %r31, 0
; CHECK-NEXT:    ld.d %r6, %r31, 8
; CHECK-NEXT:    or %r3, %r5, %r7
; CHECK-NEXT:    or %r2, %r4, %r6
; CHECK-NEXT:    jmp %r1
  %sum = or i64 %a, %b
  ret i64 %sum
}

; Float arguments passed in r2 and r3.
define float @f4(float %a, float %b) {
; CHECK-LABEL: f4:
; CHECK:       | %bb.0:
; CHECK-NEXT:    fadd.sss %r2, %r2, %r3
; CHECK-NEXT:    jmp %r1
  %sum = fadd float %a, %b
  ret float %sum
}

; Registers r2 to r9 used, no parameter passed on stack.
define i64 @f5(i64 %a, i64 %b, i64 %c, i64 %d) {
; CHECK-LABEL: f5:
; CHECK:       | %bb.0:
; CHECK-NEXT:    and %r3, %r3, %r5
; CHECK-NEXT:    and %r2, %r2, %r4
; CHECK-NEXT:    and %r3, %r3, %r7
; CHECK-NEXT:    and %r2, %r2, %r6
; CHECK-NEXT:    and %r3, %r3, %r9
; CHECK-NEXT:    and %r2, %r2, %r8
; CHECK-NEXT:    jmp %r1
  %res0 = and i64 %a, %b
  %res1 = and i64 %res0, %c
  %res = and i64 %res1, %d
  ret i64 %res
}

; Registers r2 to r5 used, no parameter passed on stack.
define double @f6(double %a, double %b) {
; CHECK-LABEL: f6:
; CHECK:       | %bb.0:
; CHECK-NEXT:    | kill: def $r3 killed $r3 killed $r2_r3 def $r2_r3
; CHECK-NEXT:    | kill: def $r2 killed $r2 killed $r2_r3 def $r2_r3
; CHECK-NEXT:    | kill: def $r5 killed $r5 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    | kill: def $r4 killed $r4 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    fadd.ddd %r2, %r2, %r4
; CHECK-NEXT:    jmp %r1
  %sum = fadd double %a, %b
  ret double %sum
}

; Registers r2 to r9 used, 1 parameter passed on stack.
define double @f7(double %a, double %b, double %c, double %d, double %e) {
; CHECK-LABEL: f7:
; CHECK:       | %bb.0:
; CHECK-NEXT:    | kill: def $r3 killed $r3 killed $r2_r3 def $r2_r3
; CHECK-NEXT:    | kill: def $r2 killed $r2 killed $r2_r3 def $r2_r3
; CHECK-NEXT:    | kill: def $r5 killed $r5 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    | kill: def $r4 killed $r4 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    | kill: def $r7 killed $r7 killed $r6_r7 def $r6_r7
; CHECK-NEXT:    | kill: def $r6 killed $r6 killed $r6_r7 def $r6_r7
; CHECK-NEXT:    | kill: def $r9 killed $r9 killed $r8_r9 def $r8_r9
; CHECK-NEXT:    | kill: def $r8 killed $r8 killed $r8_r9 def $r8_r9
; CHECK-NEXT:    ld.d %r10, %r31, 0
; CHECK-NEXT:    fadd.ddd %r2, %r2, %r4
; CHECK-NEXT:    fadd.ddd %r4, %r6, %r8
; CHECK-NEXT:    fadd.ddd %r2, %r2, %r4
; CHECK-NEXT:    fadd.ddd %r2, %r2, %r10
; CHECK-NEXT:    jmp %r1
  %sum0 = fadd double %a, %b
  %sum1 = fadd double %c, %d
  %sum2 = fadd double %sum0, %sum1
  %sum = fadd double %sum2, %e
  ret double %sum
}

; Registers r2 and r4:r5 used, no parameter passed on stack.
define double @f8(i32 %a, double %b) {
; CHECK-LABEL: f8:
; CHECK:       | %bb.0:
; CHECK-NEXT:    | kill: def $r5 killed $r5 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    | kill: def $r4 killed $r4 killed $r4_r5 def $r4_r5
; CHECK-NEXT:    flt.ds %r2, %r2
; CHECK-NEXT:    fadd.ddd %r2, %r2, %r4
; CHECK-NEXT:    jmp %r1
  %conv = sitofp i32 %a to double
  %sum = fadd double %conv, %b
  ret double %sum
}

%Data = type { i32, i32, i32 }

; Passing a struct by value.
define i32 @f9(ptr byval(%Data) align 4 %a) {
; CHECK-LABEL: f9:
; CHECK:       | %bb.0: | %entry
; CHECK-NEXT:    add %r2, %r31, 0
; CHECK-NEXT:    ld %r3, %r31, 0
; CHECK-NEXT:    ld %r4, %r2, 4
; CHECK-NEXT:    addu %r3, %r4, %r3
; CHECK-NEXT:    ld %r2, %r2, 8
; CHECK-NEXT:    addu %r2, %r3, %r2
; CHECK-NEXT:    jmp %r1
entry:
  %0 = load i32, ptr %a, align 4
  %b = getelementptr inbounds i8, ptr %a, i32 4
  %1 = load i32, ptr %b, align 4
  %add = add nsw i32 %1, %0
  %c = getelementptr inbounds i8, ptr %a, i32 8
  %2 = load i32, ptr %c, align 4
  %add2 = add nsw i32 %add, %2
  ret i32 %add2
}

%Data2 = type { i64, i64, i64 }

; Passing 2 structs by value. Second is 8 byte aligned.
define i64 @f10(ptr byval(%Data) align 4 %a, ptr byval(%Data2) align 8 %x) {
; CHECK-LABEL: f10:
; CHECK:       | %bb.0: | %entry
; CHECK-NEXT:    add %r2, %r31, 16
; CHECK-NEXT:    ld.d %r4, %r31, 16
; CHECK-NEXT:    ld.d %r6, %r2, 8
; CHECK-NEXT:    addu.co %r3, %r7, %r5
; CHECK-NEXT:    addu.ci %r4, %r6, %r4
; CHECK-NEXT:    ld.d %r6, %r2, 16
; CHECK-NEXT:    addu.co %r3, %r3, %r7
; CHECK-NEXT:    addu.ci %r2, %r4, %r6
; CHECK-NEXT:    jmp %r1
entry:
  %0 = load i64, ptr %x, align 8
  %b = getelementptr inbounds i8, ptr %x, i32 8
  %1 = load i64, ptr %b, align 8
  %add = add i64 %1, %0
  %c = getelementptr inbounds i8, ptr %x, i32 16
  %2 = load i64, ptr %c, align 8
  %add1 = add i64 %add, %2
  ret i64 %add1
}
