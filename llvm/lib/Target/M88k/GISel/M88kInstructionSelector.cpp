//===- M88kInstructionSelector.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kGlobalISelUtils.h"
#include "M88kMachineFunctionInfo.h"
#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "M88kTargetMachine.h"
#include "MCTargetDesc/M88kBaseInfo.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/IR/IntrinsicsM88k.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"

#define DEBUG_TYPE "m88k-isel"

using namespace llvm;
using namespace M88kGISelUtils;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

// Special matcher support for G_LO/G_HI.
template <unsigned Opcode> struct GHiLoMatch {
  MachineInstr *&I;
  GHiLoMatch(MachineInstr *&I) : I(I) {}
  bool match(const MachineRegisterInfo &MRI, Register Reg) {
    MachineInstr *TmpMI;
    if (mi_match(Reg, MRI, m_MInstr(TmpMI)) && TmpMI->getOpcode() == Opcode &&
        TmpMI->getNumOperands() == 2 && TmpMI->getOperand(1).isGlobal()) {
      I = TmpMI;
      return true;
    }
    return false;
  }
};

inline GHiLoMatch<M88k::G_LO> m_GLo(MachineInstr *&I) {
  return GHiLoMatch<M88k::G_LO>(I);
}

namespace {

class M88kInstructionSelector : public InstructionSelector {
public:
  M88kInstructionSelector(const M88kTargetMachine &TM, const M88kSubtarget &STI,
                          const M88kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage *CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override;
  static const char *getName() { return DEBUG_TYPE; }

private:
  // A lowering phase that runs before any selection attempts.
  // Returns true if the instruction was modified.
  bool preISelLower(MachineInstr &I);

  // An early selection function that runs before the selectImpl() call.
  bool earlySelect(MachineInstr &I);

  // tblgen-erated 'select' implementation, used as the initial selector for
  // the patterns that don't require complex C++.
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  bool constrainSelectedInstRegOperands(MachineInstr &I,
                                        const MachineRegisterInfo &MRI,
                                        const TargetInstrInfo &TII,
                                        const TargetRegisterInfo &TRI,
                                        const RegisterBankInfo &RBI) const;

  void renderLO16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderHI16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderNEG16(MachineInstrBuilder &MIB, const MachineInstr &I,
                   int OpIdx = -1) const;
  void renderCPOP(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderCTZ(MachineInstrBuilder &MIB, const MachineInstr &I,
                 int OpIdx = -1) const;
  void renderCPOPINV(MachineInstrBuilder &MIB, const MachineInstr &I,
                     int OpIdx = -1) const;
  void renderCTZINV(MachineInstrBuilder &MIB, const MachineInstr &I,
                    int OpIdx = -1) const;

  ComplexRendererFns selectAddrRegImm(MachineOperand &Root) const;
  ComplexRendererFns selectAddrRegReg(MachineOperand &Root) const;
  ComplexRendererFns selectAddrRegScaled(MachineOperand &Root) const;

  bool selectFrameIndex(MachineInstr &I, MachineBasicBlock &MBB,
                        MachineRegisterInfo &MRI) const;
  bool selectVaStart(MachineInstr &I, MachineBasicBlock &MBB,
                     MachineRegisterInfo &MRI) const;
  bool selectGlobalValue(MachineInstr &I, MachineBasicBlock &MBB,
                         MachineRegisterInfo &MRI) const;
  bool selectUbfx(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectICmp(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectBrCond(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectJumpTable(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;
  bool selectBrJT(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectBrIndirect(MachineInstr &I, MachineBasicBlock &MBB,
                        MachineRegisterInfo &MRI) const;
  bool selectPtrAdd(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectPtrMask(MachineInstr &I, MachineBasicBlock &MBB,
                     MachineRegisterInfo &MRI) const;
  bool selectAddSubWithCarry(MachineInstr &I, MachineBasicBlock &MBB,
                             MachineRegisterInfo &MRI,
                             bool IsRecursive = false);
  bool selectMul(MachineInstr &I, MachineBasicBlock &MBB,
                 MachineRegisterInfo &MRI) const;
  bool selectUDiv(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectExt(MachineInstr &I, MachineBasicBlock &MBB,
                 MachineRegisterInfo &MRI) const;
  bool selectLoadStore(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;
  bool selectMergeUnmerge(MachineInstr &I, MachineBasicBlock &MBB,
                          MachineRegisterInfo &MRI) const;
  bool selectIntrinsic(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI);

  bool isMC88110() const {
    return TII.getSubtarget().isMC88110();
  }

  bool useDivInstr() const {
    return TM.useDivInstr();
  }

  bool noZeroDivCheck() const {
    return TM.noZeroDivCheck();
  }

  const M88kTargetMachine &TM;
  const M88kInstrInfo &TII;
  const M88kRegisterInfo &TRI;
  const M88kRegisterBankInfo &RBI;

  // Some cached values used during selection.
  // We use R1 as a live-in register, and we keep track of it here as it can be
  // clobbered by calls.
  Register MFReturnAddr;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M88kInstructionSelector::M88kInstructionSelector(
    const M88kTargetMachine &TM, const M88kSubtarget &STI,
    const M88kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

// Like llvm::getSrcRegIgnoringCopies() but returns the register from argument
// list instead of None.
static Register getRegIgnoringCopies(Register Reg,
                                     const MachineRegisterInfo &MRI) {
  std::optional<DefinitionAndSourceRegister> DefSrcReg =
      getDefSrcRegIgnoringCopies(Reg, MRI);
  return DefSrcReg ? DefSrcReg->Reg : Reg;
}

static const TargetRegisterClass *guessRegClass(unsigned Reg,
                                                MachineRegisterInfo &MRI,
                                                const TargetRegisterInfo &TRI,
                                                const RegisterBankInfo &RBI) {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  assert(RegBank && "Can't get reg bank for virtual register");

  const unsigned Size = MRI.getType(Reg).getSizeInBits();
  assert((RegBank->getID() == M88k::GRRegBankID ||
          RegBank->getID() == M88k::XRRegBankID) &&
         "Unsupported reg bank");

  if (RegBank->getID() == M88k::XRRegBankID)
    return &M88k::XRRegClass;

  if (Size == 64)
    return &M88k::GPR64RegClass;
  return &M88k::GPRRegClass;
}

static bool selectCopy(MachineInstr &I, const TargetInstrInfo &TII,
                       MachineRegisterInfo &MRI, const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {
  Register SrcReg = I.getOperand(1).getReg();
  if (Register::isVirtualRegister(SrcReg) &&
      MRI.getType(SrcReg) == LLT::pointer(0, 32))
    if (std::optional<APInt> Cst = getIConstantVRegVal(SrcReg, MRI);
        Cst && Cst->isZero())
      I.getOperand(1).setReg(M88k::R0);

  Register DstReg = I.getOperand(0).getReg();
  if (Register::isPhysicalRegister(DstReg))
    return true;

  const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }
  I.setDesc(TII.get(TargetOpcode::COPY));
  return true;
}

bool M88kInstructionSelector::constrainSelectedInstRegOperands(
    MachineInstr &I, const MachineRegisterInfo &MRI, const TargetInstrInfo &TII,
    const TargetRegisterInfo &TRI, const RegisterBankInfo &RBI) const {
  for (MachineOperand &OP : I.explicit_operands()) {
    if (!OP.isReg() || OP.isDef())
      continue;
    Register Reg = OP.getReg();
    if (Register::isPhysicalRegister(Reg))
      continue;
    std::optional<ValueAndVReg> Res =
        getIConstantVRegValWithLookThrough(Reg, MRI, true);
    // TODO This needs an update when the XR register class is supported.
    if (Res && Res->Value.isZero())
      OP.setReg(M88k::R0);
  }
  return ::constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

void M88kInstructionSelector::renderLO16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val &= 0x000000000000FFFFULL;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderHI16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val = (Val & 0x00000000FFFF0000ULL) >> 16;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderNEG16(MachineInstrBuilder &MIB,
                                          const MachineInstr &I,
                                          int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  int64_t Val = I.getOperand(1).getCImm()->getSExtValue();
  MIB.addImm(-Val);
}

void M88kInstructionSelector::renderCPOP(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  MIB.addImm(popcount(Val) & 0x1f);
}

void M88kInstructionSelector::renderCTZ(MachineInstrBuilder &MIB,
                                        const MachineInstr &I,
                                        int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  MIB.addImm(countr_zero(Val) & 0x1f);
}

void M88kInstructionSelector::renderCPOPINV(MachineInstrBuilder &MIB,
                                            const MachineInstr &I,
                                            int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = ~I.getOperand(1).getCImm()->getZExtValue() & 0xffffffff;
  MIB.addImm(popcount(Val) & 0x1f);
}

void M88kInstructionSelector::renderCTZINV(MachineInstrBuilder &MIB,
                                           const MachineInstr &I,
                                           int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = ~I.getOperand(1).getCImm()->getZExtValue() & 0xffffffff;
  MIB.addImm(countr_zero(Val) & 0x1f);
}

static bool isUnalignedAccess(MachineInstr &MI) {
  const auto &MMO = dyn_cast<GMemOperation>(&MI)->getMMO();
  return MMO.getAlign() < MMO.getSize();
}

InstructionSelector::ComplexRendererFns
M88kInstructionSelector::selectAddrRegImm(MachineOperand &Root) const {
  MachineInstr &MI = *Root.getParent();
  MachineFunction &MF = *MI.getParent()->getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (!Root.isReg() || isUnalignedAccess(MI))
    return std::nullopt;

  MachineInstr *RootDef = getDefIgnoringCopies(Root.getReg(), MRI);

  // Match load from LO/HI address.
  MachineInstr *Lo;
  Register Hi;
  if (mi_match(RootDef, MRI, m_GIntToPtr(m_GOr(m_Reg(Hi), m_GLo(Lo))))) {
    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addReg(Hi); },
        [=](MachineInstrBuilder &MIB) {
          MIB.addGlobalAddress(Lo->getOperand(1).getGlobal(), 0,
                               M88kII::MO_ABS_LO);
        },
    }};
  }

  MachineInstr *TmpMI;
  if (mi_match(RootDef, MRI, m_MInstr(TmpMI))) {
    // A frame index is always matched to the reg-imm address.
    if (TmpMI->getOpcode() == TargetOpcode::G_FRAME_INDEX) {
      return {{
          [=](MachineInstrBuilder &MIB) { MIB.add(TmpMI->getOperand(1)); },
          [=](MachineInstrBuilder &MIB) { MIB.addImm(0); },
      }};
    }
    // Handle the case of a simple address.
    if (TmpMI->getOpcode() != TargetOpcode::G_PTR_ADD) {
      return {{
          [=](MachineInstrBuilder &MIB) {
            MIB.addReg(TmpMI->getOperand(0).getReg());
          },
          [=](MachineInstrBuilder &MIB) { MIB.addImm(0); },
      }};
    }
  }

  // Check for G_PTR_ADD plus 16 bit offset.
  // Follow a chain of G_PTR_ADD instructsions, as long as a constant is added,
  // and the accumulated offset still fits into 16 bit.
  Register PtrAddBase;
  int64_t PtrAddOffset;
  if (mi_match(RootDef, MRI,
               m_GPtrAdd(m_Reg(PtrAddBase), m_ICst(PtrAddOffset))) &&
      isUInt<16>(PtrAddOffset)) {
    Register Base = PtrAddBase;
    int64_t Offset = PtrAddOffset;
    while (mi_match(Base, MRI,
                    m_GPtrAdd(m_Reg(PtrAddBase), m_ICst(PtrAddOffset))) &&
           isUInt<16>(Offset + PtrAddOffset)) {
      Base = PtrAddBase;
      Offset += PtrAddOffset;
    }
    Base = getRegIgnoringCopies(Base, MRI);
    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addReg(Base); },
        [=](MachineInstrBuilder &MIB) { MIB.addImm(Offset); },
    }};
  }

  return std::nullopt;
}

InstructionSelector::ComplexRendererFns
M88kInstructionSelector::selectAddrRegReg(MachineOperand &Root) const {
  MachineInstr &MI = *Root.getParent();
  MachineFunction &MF = *MI.getParent()->getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (!Root.isReg() || isUnalignedAccess(MI))
    return std::nullopt;

  // Check for G_PTR_ADD plus 16 bit offset.
  MachineInstr *RootDef = getDefIgnoringCopies(Root.getReg(), MRI);
  Register Base, Offset;
  if (mi_match(RootDef, MRI, m_GPtrAdd(m_Reg(Base), m_Reg(Offset)))) {
    Register BaseReg = getRegIgnoringCopies(Base, MRI);
    Register OffsetReg = getRegIgnoringCopies(Offset, MRI);
    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addReg(BaseReg); },
        [=](MachineInstrBuilder &MIB) { MIB.addReg(OffsetReg); },
    }};
  }

  return std::nullopt;
}

InstructionSelector::ComplexRendererFns
M88kInstructionSelector::selectAddrRegScaled(MachineOperand &Root) const {
  GMemOperation &MI = *dyn_cast<GMemOperation>(Root.getParent());
  MachineFunction &MF = *MI.getParent()->getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (!Root.isReg() || isUnalignedAccess(MI))
    return std::nullopt;

  // Check for G_PTR_ADD plus shifted register.
  MachineInstr *RootDef = getDefIgnoringCopies(Root.getReg(), MRI);
  Register Base, Scaled;
  if (mi_match(RootDef, MRI,
               m_GPtrAdd(m_Reg(Base),
                         m_GShl(m_Reg(Scaled),
                                m_SpecificICst(Log2_32(MI.getMemSize())))))) {
    Register BaseReg = getRegIgnoringCopies(Base, MRI);
    Register ScaledReg = getRegIgnoringCopies(Scaled, MRI);
    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addReg(BaseReg); },
        [=](MachineInstrBuilder &MIB) { MIB.addReg(ScaledReg); },
    }};
  }

  return std::nullopt;
}

bool M88kInstructionSelector::selectFrameIndex(MachineInstr &I,
                                               MachineBasicBlock &MBB,
                                               MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_FRAME_INDEX && "Unexpected G code");

  I.setDesc(TII.get(M88k::ADDri));
  I.addOperand(MachineOperand::CreateImm(0));
  return constrainSelectedInstRegOperands(I, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectVaStart(MachineInstr &I,
                                               MachineBasicBlock &MBB,
                                               MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_VASTART && "Unexpected G code");

  MachineFunction &MF = *MBB.getParent();
  M88kMachineFunctionInfo *FuncInfo = MF.getInfo<M88kMachineFunctionInfo>();

  Register VaList = I.getOperand(0).getReg();

  // Store the number of the first var arg register.
  Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
                         .addReg(Temp, RegState::Define)
                         .addReg(M88k::R0)
                         .addImm(FuncInfo->getVarArgsFirstReg());
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::STriw))
                         .addReg(Temp, RegState::Kill)
                         .addReg(VaList)
                         .addImm(0);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  // Store the pointer to the argument area on the stack.
  Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDri))
                         .addReg(Temp, RegState::Define)
                         .addFrameIndex(FuncInfo->getStackIndex())
                         .addImm(0);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::STriw))
                         .addReg(Temp, RegState::Kill)
                         .addReg(VaList)
                         .addImm(4);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  // Store the pointer to the register save area.
  Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDri))
                         .addReg(Temp, RegState::Define)
                         .addFrameIndex(FuncInfo->getVarArgsRegIndex())
                         .addImm(0);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::STriw))
                         .addReg(Temp, RegState::Kill)
                         .addReg(VaList)
                         .addImm(8);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  I.eraseFromParent();
  return true;
}

bool M88kInstructionSelector::selectGlobalValue(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_GLOBAL_VALUE && "Unexpected G code");

  const GlobalValue *GV = I.getOperand(1).getGlobal();

  Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
                         .addReg(Temp, RegState::Define)
                         .addReg(M88k::R0)
                         .addGlobalAddress(GV, 0, M88kII::MO_ABS_HI);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
           .add(I.getOperand(0))
           .addReg(Temp, RegState::Kill)
           .addGlobalAddress(GV, 0, M88kII::MO_ABS_LO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectUbfx(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_UBFX ||
         I.getOpcode() == TargetOpcode::G_SBFX ||
         I.getOpcode() == TargetOpcode::G_SEXT_INREG && "Unexpected G code");

  const unsigned NewOpc =
      I.getOpcode() == TargetOpcode::G_UBFX ? M88k::EXTUrwo : M88k::EXTrwo;
  uint64_t Width, Offset;
  if (I.getOpcode() == TargetOpcode::G_SEXT_INREG) {
    // For G_SEXT_INREG, the width is the immediate in operand 2. The offset is
    // always 0.
    Width = I.getOperand(2).getImm() + 1;
    assert(Width < 32 && "Can't sign-extend 32bit value");
    Offset = 0;
  } else {
    auto OffsetCst =
        getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
    if (!OffsetCst)
      return false;
    Offset = OffsetCst->Value.getZExtValue();

    auto WidthCst =
        getIConstantVRegValWithLookThrough(I.getOperand(3).getReg(), MRI, true);
    if (!WidthCst)
      return false;

    Width = WidthCst->Value.getZExtValue();
  }

  I.setDesc(TII.get(NewOpc));
  I.getOperand(2).ChangeToImmediate(Width);
  I.getOperand(3).ChangeToImmediate(Offset);
  return constrainSelectedInstRegOperands(I, MRI, TII, TRI, RBI);
}

enum class ICC : unsigned {
  EQ = 2,  // equal
  NE = 3,  // not equal
  GT = 4,  // signed greater than
  LE = 5,  // signed less than or equal
  LT = 6,  // signed less than
  GE = 7,  // signed greater than or equal
  HI = 8,  // unsigned greater than
  LS = 9,  // unsigned less than or equal
  LO = 10, // unsigned less than
  HS = 11, // unsigned greater than or equal
  BE = 12, // any byte equal
  NB = 13, // no byte equal
  HE = 14, // any half-word equal
  NH = 15  // no half-word equal
};

static ICC getCCforICMP(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return ICC::EQ;
  case CmpInst::ICMP_NE:
    return ICC::NE;
  case CmpInst::ICMP_UGT:
    return ICC::HI;
  case CmpInst::ICMP_UGE:
    return ICC::HS;
  case CmpInst::ICMP_ULT:
    return ICC::LO;
  case CmpInst::ICMP_ULE:
    return ICC::LS;
  case CmpInst::ICMP_SGT:
    return ICC::GT;
  case CmpInst::ICMP_SGE:
    return ICC::GE;
  case CmpInst::ICMP_SLT:
    return ICC::LT;
  case CmpInst::ICMP_SLE:
    return ICC::LE;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

enum class CC0 : unsigned {
  EQ0 = 0x2,
  NE0 = 0xd,
  GT0 = 0x1,
  LT0 = 0xc,
  GE0 = 0x3,
  LE0 = 0xe
};

static CC0 getCCforBCOND(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return CC0::EQ0;
  case CmpInst::ICMP_NE:
    return CC0::NE0;
  case CmpInst::ICMP_SGT:
    return CC0::GT0;
  case CmpInst::ICMP_SGE:
    return CC0::GE0;
  case CmpInst::ICMP_SLT:
    return CC0::LT0;
  case CmpInst::ICMP_SLE:
    return CC0::LE0;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

bool M88kInstructionSelector::selectICmp(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "Unexpected G code");

  MachineInstr *MI = nullptr;
  CmpInst::Predicate Pred =
      static_cast<CmpInst::Predicate>(I.getOperand(1).getPredicate());
  ICC CCCode = getCCforICMP(Pred);
  Register LHS = I.getOperand(2).getReg();
  Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);

  auto Cst =
      getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
  if (Cst && isInt<16>(Cst->Value.getZExtValue())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addImm(Cst->Value.getZExtValue());
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .add(I.getOperand(3));
  }
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::EXTUrwo))
           .add(I.getOperand(0))
           .addReg(Temp, RegState::Kill)
           .addImm(1)
           .addImm(int64_t(CCCode));

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrCond(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "Unexpected G code");
  // Match combinations of G_BRCND and G_ICMP/G_FCMP or
  // combinations of G_BRCOND and G_TRUNC of G_AND/G_XOR.

  // G_ICMP: $tst, $src1, $src2
  // G_BRCOND: $tst, $truebb
  MachineInstr *MI = nullptr;
  Register CC = I.getOperand(0).getReg();
  MachineBasicBlock *BB = I.getOperand(1).getMBB();
  CmpInst::Predicate Pred;
  Register LHS, RHS, Reg;
  int64_t UImm16;
  if (mi_match(CC, MRI, m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(UImm16))) &&
      isUInt<16>(UImm16)) {
    if (UImm16 == 0) {
      CC0 CCCode = getCCforBCOND(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BCND))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(LHS)
               .addMBB(BB);
    } else {
      Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
      ICC CCCode = getCCforICMP(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
               .addReg(Temp, RegState::Define)
               .addReg(LHS)
               .addImm(UImm16);
      if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
        return false;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(Temp, RegState::Kill)
               .addMBB(BB);
    }
  } else if (mi_match(CC, MRI, m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(static_cast<int64_t>(CCCode))
             .addReg(Temp, RegState::Kill)
             .addMBB(BB);
  } else if (mi_match(
                 CC, MRI,
                 m_GTrunc(m_any_of(m_GAnd(m_Reg(Reg), m_SpecificICst(1)),
                                   m_GXor(m_GXor(m_Reg(Reg), m_SpecificICst(1)),
                                          m_SpecificICst(1)))))) {
    // TODO The xor(xor %r, 1), 1) pattern should be handled by a combiner.
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(0)
             .addReg(Reg)
             .addMBB(BB);
  } else if (mi_match(CC, MRI,
                      m_GTrunc(m_GXor(m_Reg(Reg), m_SpecificICst(1))))) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB0))
             .addImm(0)
             .addReg(Reg)
             .addMBB(BB);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(0)
             .addReg(CC)
             .addMBB(BB);
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectJumpTable(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_JUMP_TABLE && "Unexpected G code");

  MachineInstr *MI = nullptr;
  Register Reg = I.getOperand(0).getReg();
  int JTIndex = I.getOperand(1).getIndex();

  Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
           .addReg(Temp, RegState::Define)
           .addReg(M88k::R0)
           .addJumpTableIndex(JTIndex, M88kII::MO_ABS_HI);
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
           .addReg(Reg, RegState::Define)
           .addReg(Temp, RegState::Kill)
           .addJumpTableIndex(JTIndex, M88kII::MO_ABS_LO);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrJT(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRJT && "Unexpected G code");

  MachineInstr *MI = nullptr;
  MachineFunction &MF = *I.getParent()->getParent();
  unsigned EntrySize = MF.getJumpTableInfo()->getEntrySize(MF.getDataLayout());
  assert((EntrySize == 0 || EntrySize == 4) &&
         "Unsupported size of jump-table entry.");

  Register JTPtrReg = I.getOperand(0).getReg();
  Register JTIndexReg = I.getOperand(2).getReg();

  Register DstReg = MRI.createVirtualRegister(&M88k::GPRRegClass);
  if (EntrySize == 4) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDrrsw))
             .addReg(DstReg, RegState::Define)
             .addReg(JTPtrReg)
             .addReg(JTIndexReg);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDrruw))
             .addReg(DstReg, RegState::Define)
             .addReg(JTPtrReg)
             .addReg(JTIndexReg);
  }
  if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::JMP)).addReg(DstReg);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrIndirect(MachineInstr &I,
                                               MachineBasicBlock &MBB,
                                               MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRINDIRECT && "Unexpected G code");

  I.setDesc(TII.get(M88k::JMP));
  return constrainSelectedInstRegOperands(I, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectPtrAdd(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_PTR_ADD && "Unexpected G code");

  Register AddendReg = I.getOperand(2).getReg();

  int64_t Offset;
  if (mi_match(AddendReg, MRI, m_ICst(Offset)) && isUInt<16>(Offset)) {
    I.setDesc(TII.get(M88k::ADDUri));
    I.getOperand(2).ChangeToImmediate(Offset);
  } else {
    I.setDesc(TII.get(M88k::ADDUrr));
  }
  return constrainSelectedInstRegOperands(I, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectPtrMask(MachineInstr &I,
                                            MachineBasicBlock &MBB,
                                            MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_PTRMASK && "Unexpected G code");

  Register MaskReg = I.getOperand(2).getReg();
  std::optional<int64_t> MaskVal = getIConstantVRegSExtVal(MaskReg, MRI);
  // TODO: Implement arbitrary cases
  if (!MaskVal || !isInt<32>(*MaskVal) || !isShiftedMask_64(*MaskVal))
    return false;

  uint32_t Mask = ~static_cast<uint32_t>(*MaskVal);
  I.setDesc(TII.get(M88k::CLRrwo));
  I.getOperand(2).ChangeToImmediate(popcount(Mask));
  I.addOperand(MachineOperand::CreateImm(countr_zero(Mask)));

  return constrainSelectedInstRegOperands(I, MRI, TII, TRI, RBI);
}

bool isCarryChangedByInstr(const MachineInstr *I, MachineRegisterInfo &MRI) {
  if (auto *CarryI = dyn_cast<GAddSubCarryOut>(I))
    return !MRI.use_nodbg_empty(CarryI->getCarryOutReg());
  unsigned Opc = I->getOpcode();
  return Opc == M88k::ADDUrrco || Opc == M88k::ADDUrrcio ||
         Opc == M88k::SUBUrrco || Opc == M88k::SUBUrrcio;
}

bool M88kInstructionSelector::selectAddSubWithCarry(MachineInstr &I,
                                                    MachineBasicBlock &MBB,
                                                    MachineRegisterInfo &MRI,
                                                    bool IsRecursive) {
  assert(I.getOpcode() == TargetOpcode::G_UADDO ||
         I.getOpcode() == TargetOpcode::G_USUBO ||
         I.getOpcode() == TargetOpcode::G_UADDE ||
         I.getOpcode() == TargetOpcode::G_USUBE && "Unexpected G code");

  // If the instruction consumes a carry flag, then we need to make sure that
  // the flag is not destroyed.
  //  - If between the instruction and the carry-producing instruction is no
  //    other instruction which produces a carry, then there is no need to copy
  //    the carry into a virtual register. However, this could turn the
  //    carry-producing instruction dead, because the def-use relationship is
  //    broken. To prevent this situation, the carry-producing instruction is
  //    selected first.
  //  - Otherwise, the carry-in virtual register is copied into the carry flag.
  if (auto *CarryInMI = dyn_cast<GAddSubCarryInOut>(&I)) {
    bool SetCarry = true;
    MachineInstr *SrcMI = MRI.getVRegDef(CarryInMI->getCarryInReg());
    if (SrcMI->getParent() == &MBB) {
      for (auto MI = std::next(MachineBasicBlock::const_reverse_iterator(&I));;
           ++MI) {
        if (MI == SrcMI) {
          if (!selectAddSubWithCarry(*SrcMI, *SrcMI->getParent(), MRI, true))
            break;
          SetCarry = false;
          break;
        }
        if (isCarryChangedByInstr(&*MI, MRI))
          break;
      }
    }
    if (SetCarry) {
      Register DeadReg = MRI.createVirtualRegister(&M88k::GPRRegClass);
      MachineInstr *MI =
          BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::SUBUrrco), DeadReg)
              .addReg(M88k::R0)
              .addReg(CarryInMI->getCarryInReg());
      if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
        return false;
    }
  }

  static unsigned TargetOpc[] = {
      M88k::ADDUrrco, M88k::ADDUrrci, M88k::ADDUrrcio, // Add
      M88k::SUBUrrco, M88k::SUBUrrci, M88k::SUBUrrcio, // Sub
  };

  auto &CarryMI = cast<GAddSubCarryOut>(I);
  Register DstReg = CarryMI.getDstReg();
  Register Src1Reg = CarryMI.getLHS().getReg();
  Register Src2Reg = CarryMI.getRHS().getReg();
  Register CarryOutReg = CarryMI.getCarryOutReg();

  bool HasCarryInOut = isa<GAddSubCarryInOut>(&CarryMI);
  bool IsCarryOutUsed = !MRI.use_nodbg_empty(CarryOutReg);
  bool IsCarryInOutUsed = HasCarryInOut && IsCarryOutUsed;
  bool IsSub = CarryMI.isSub();
  unsigned NewOpc = TargetOpc[3 * IsSub + HasCarryInOut + IsCarryInOutUsed];

  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc), DstReg)
                         .addReg(Src1Reg)
                         .addReg(Src2Reg);

  if (IsCarryOutUsed) {
    // If the carry out is used, then we do not need to copy the carry to a
    // register if it is a recursive call and there is only exactly one non-
    // debug use.
    if (!IsRecursive || hasNItemsOrMore(MRI.use_nodbg_begin(CarryOutReg),
                                        MRI.use_nodbg_end(), 2)) {
      // Do not copy the carry flag into a virtual register if it is not used.
      // This instruction may be dead if the carry-consuming instruction uses
      // the carry flag directly.
      if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
        return false;
      MI =
          BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDUrrci), CarryOutReg)
              .addReg(M88k::R0)
              .addReg(M88k::R0);
    }
  }
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectMul(MachineInstr &I, MachineBasicBlock &MBB,
                                        MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_MUL && "Unexpected G code");

  // Only selects special mulu.d instruction, the other mul instructions are
  // matched by the patterns from the target description.
  if (!isMC88110())
    return false;

  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  MachineInstr *Merge1MI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src1Reg, MRI);
  MachineInstr *Merge2MI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src2Reg, MRI);
  if (Merge1MI &&
      mi_match(Merge1MI->getOperand(1).getReg(), MRI, m_ZeroInt()) &&
      Merge2MI &&
      mi_match(Merge2MI->getOperand(1).getReg(), MRI, m_ZeroInt())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::MULUrrd), DstReg)
             .addReg(Merge1MI->getOperand(2).getReg())
             .addReg(Merge2MI->getOperand(2).getReg());
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectUDiv(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_UDIV && "Unexpected G code");

  // Only selects special divu.d instruction, the other div instructions are
  // matched by the patterns from the target description.
  if (!isMC88110())
    return false;

  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  MachineInstr *MergeMI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src2Reg, MRI);
  if (MergeMI && mi_match(MergeMI->getOperand(1).getReg(), MRI, m_ZeroInt())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::DIVUrrd), DstReg)
             .addReg(Src1Reg)
             .addReg(MergeMI->getOperand(2).getReg());
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectExt(MachineInstr &I, MachineBasicBlock &MBB,
                                        MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ZEXT ||
         I.getOpcode() == TargetOpcode::G_ANYEXT ||
         I.getOpcode() == TargetOpcode::G_SEXT && "Unexpected G code");

  // Matches xEXT of ICMP.
  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  const unsigned NewOpc =
      I.getOpcode() == TargetOpcode::G_SEXT ? M88k::EXTrwo : M88k::EXTUrwo;
  CmpInst::Predicate Pred;
  Register LHS, RHS;
  int64_t SImm16;
  if (mi_match(SrcReg, MRI,
               m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(SImm16))) &&
      isInt<16>(SImm16)) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addImm(SImm16);
    if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc), DstReg)
             .addReg(Temp, RegState::Kill)
             .addImm(1)
             .addImm(int64_t(CCCode));
  } else if (mi_match(SrcReg, MRI,
                      m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc), DstReg)
             .addReg(Temp, RegState::Kill)
             .addImm(1)
             .addImm(int64_t(CCCode));
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectMergeUnmerge(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_MERGE_VALUES ||
         I.getOpcode() == TargetOpcode::G_UNMERGE_VALUES &&
             "Unexpected G code");

  if (I.getOpcode() == TargetOpcode::G_MERGE_VALUES) {
    Register DstReg = I.getOperand(0).getReg();
    Register LoReg = I.getOperand(1).getReg();
    Register HiReg = I.getOperand(2).getReg();
    BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::REG_SEQUENCE),
            DstReg)
        .addUse(LoReg)
        .addImm(M88k::sub_lo)
        .addUse(HiReg)
        .addImm(M88k::sub_hi);
    RBI.constrainGenericRegister(DstReg, M88k::GPR64RegClass, MRI);
  } else {
    Register SrcReg = I.getOperand(2).getReg();

    // Copy to dst.
    BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
            I.getOperand(0).getReg())
        .addReg(SrcReg, 0, M88k::sub_lo);
    RBI.constrainGenericRegister(I.getOperand(0).getReg(), M88k::GPRRegClass,
                                 MRI);

    BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
            I.getOperand(1).getReg())
        .addReg(SrcReg, 0, M88k::sub_hi);
    RBI.constrainGenericRegister(I.getOperand(1).getReg(), M88k::GPRRegClass,
                                 MRI);
  }
  I.eraseFromParent();
  return true;
}

bool M88kInstructionSelector::selectIntrinsic(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) {
  unsigned IntrinID = cast<GIntrinsic>(I).getIntrinsicID();
  MachineInstr *MI = nullptr;

  switch (IntrinID) {
  default:
    break;
  case Intrinsic::frameaddress:
  case Intrinsic::returnaddress: {
    MachineFunction &MF = *I.getParent()->getParent();
    MachineFrameInfo &MFI = MF.getFrameInfo();

    unsigned Depth = I.getOperand(2).getImm();
    Register DstReg = I.getOperand(0).getReg();
    RBI.constrainGenericRegister(DstReg, M88k::GPRRegClass, MRI);

    if (Depth == 0 && IntrinID == Intrinsic::returnaddress) {
      if (!MFReturnAddr) {
        // Insert the copy from R1 into the entry block, before it can be
        // clobbered by anything.
        MFI.setReturnAddressIsTaken(true);
        MFReturnAddr = getFunctionLiveInPhysReg(
            MF, TII, M88k::R1, M88k::GPRRegClass, I.getDebugLoc());
      }

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(MFReturnAddr);

      I.eraseFromParent();
      return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
    }

    MFI.setFrameAddressIsTaken(true);
    Register FrameAddr(M88k::R30);
    while (Depth--) {
      Register NextFrame = MRI.createVirtualRegister(&M88k::GPRRegClass);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), NextFrame)
               .addUse(FrameAddr)
               .addImm(0);

      constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
      FrameAddr = NextFrame;
    }

    if (IntrinID == Intrinsic::frameaddress)
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(FrameAddr);
    else {
      MFI.setReturnAddressIsTaken(true);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), DstReg)
               .addUse(FrameAddr)
               .addImm(4);
    }

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
  }
  }
  return false;
}

bool M88kInstructionSelector::preISelLower(MachineInstr &I) {
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  switch (I.getOpcode()) {
  case TargetOpcode::G_STORE: {
    bool Changed = false;
    MachineOperand &SrcOp = I.getOperand(0);
    if (MRI.getType(SrcOp.getReg()).isPointer()) {
      // Allow matching with imported patterns for stores of pointers. Unlike
      // G_LOAD/G_PTR_ADD, we may not have selected all users. So, emit a copy
      // and constrain.
      Register NewSrc = MRI.createVirtualRegister(&M88k::GPRRegClass);
      BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), NewSrc)
          .addReg(SrcOp.getReg());
      MRI.setType(NewSrc, LLT::scalar(32));
      SrcOp.setReg(NewSrc);
      RBI.constrainGenericRegister(NewSrc, M88k::GPRRegClass, MRI);
      Changed = true;
    }
    return Changed;
  }
  // case TargetOpcode::G_PTR_ADD:
  //   return convertPtrAddToAdd(I, MRI);
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_LOAD: {
    // For scalar loads of pointers, we try to convert the dest type from p0
    // to s32 so that our imported patterns can match. Like with the G_PTR_ADD
    // conversion, this should be ok because all users should have been
    // selected already, so the type doesn't matter for them.
    Register DstReg = I.getOperand(0).getReg();
    const LLT DstTy = MRI.getType(DstReg);
    if (!DstTy.isPointer())
      return false;
    MRI.setType(DstReg, LLT::scalar(32));
    return true;
  }
  default:
    return false;
  }
}

bool M88kInstructionSelector::earlySelect(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  switch (I.getOpcode()) {
  case TargetOpcode::G_OR: {
    MachineInstr *Lo;
    Register Hi;
    if (mi_match(I, MRI, m_GOr(m_Reg(Hi), m_GLo(Lo)))) {
      const GlobalValue *GV = Lo->getOperand(1).getGlobal();
      auto MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
                    .addReg(I.getOperand(0).getReg(), RegState::Define)
                    .addReg(Hi)
                    .addGlobalAddress(GV, 0, M88kII::MO_ABS_LO);
      I.eraseFromParent();
      return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
    }
    return false;
  }
  case M88k::G_LO:
  case M88k::G_HI: {
    // G_LO and G_HI cannot be imported because a tglobaladdr operand is not
    // supported.
    const GlobalValue *GV = I.getOperand(1).getGlobal();
    bool IsLo = I.getOpcode() == M88k::G_LO;
    M88kII::TOF Flag = IsLo ? M88kII::MO_ABS_LO : M88kII::MO_ABS_HI;
    unsigned Opcode = IsLo ? M88k::ORri : M88k::ORriu;
    auto MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(Opcode))
                  .addReg(I.getOperand(0).getReg(), RegState::Define)
                  .addReg(M88k::R0)
                  .addGlobalAddress(GV, 0, Flag);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, MRI, TII, TRI, RBI);
  }
  default:
    return false;
  }
}

void M88kInstructionSelector::setupMF(MachineFunction &MF, GISelKnownBits *KB,
                                      CodeGenCoverage *CoverageInfo,
                                      ProfileSummaryInfo *PSI,
                                      BlockFrequencyInfo *BFI) {
  InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
  MFReturnAddr = Register();
}

bool M88kInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  // Certain non-generic instructions also need some special handling.
  if (!I.isPreISelOpcode()) {
    if (I.isCopy())
      return selectCopy(I, TII, MRI, TRI, RBI);

    return true;
  }

  // Try to do some lowering before we start instruction selecting. These
  // lowerings are purely transformations on the input G_MIR and so selection
  // must continue after any modification of the instruction.
  preISelLower(I);

  // There may be patterns where the importer can't deal with them optimally,
  // but does select it to a suboptimal sequence so our custom C++ selection
  // code later never has a chance to work on it. Therefore, we have an early
  // selection attempt here to give priority to certain selection routines
  // over the imported ones.
  if (earlySelect(I))
    return true;

  if (selectImpl(I, *CoverageInfo))
    return true;

  switch (I.getOpcode()) {
  case TargetOpcode::G_INTTOPTR:
  case TargetOpcode::G_PTRTOINT:
  case TargetOpcode::G_FREEZE:
    return selectCopy(I, TII, MRI, TRI, RBI);
  case TargetOpcode::G_INTRINSIC:
    return selectIntrinsic(I, MBB, MRI);
  case TargetOpcode::G_GLOBAL_VALUE:
    return selectGlobalValue(I, MBB, MRI);
  case TargetOpcode::G_PTR_ADD:
    return selectPtrAdd(I, MBB, MRI);
  case TargetOpcode::G_PTRMASK:
    return selectPtrMask(I, MBB, MRI);
  case TargetOpcode::G_FRAME_INDEX:
    return selectFrameIndex(I, MBB, MRI);
  case TargetOpcode::G_VASTART:
    return selectVaStart(I, MBB, MRI);
  case TargetOpcode::G_UBFX:
  case TargetOpcode::G_SBFX:
  case TargetOpcode::G_SEXT_INREG:
    return selectUbfx(I, MBB, MRI);
  case TargetOpcode::G_ICMP:
    return selectICmp(I, MBB, MRI);
  case TargetOpcode::G_BRCOND:
    return selectBrCond(I, MBB, MRI);
  case TargetOpcode::G_JUMP_TABLE:
    return selectJumpTable(I, MBB, MRI);
  case TargetOpcode::G_BRJT:
    return selectBrJT(I, MBB, MRI);
  case TargetOpcode::G_BRINDIRECT:
    return selectBrIndirect(I, MBB, MRI);
  case TargetOpcode::G_UADDO:
  case TargetOpcode::G_USUBO:
  case TargetOpcode::G_UADDE:
  case TargetOpcode::G_USUBE:
    return selectAddSubWithCarry(I, MBB, MRI);
  case TargetOpcode::G_MUL:
    return selectMul(I, MBB, MRI);
  case TargetOpcode::G_UDIV:
    return selectUDiv(I, MBB, MRI);
  case TargetOpcode::G_ZEXT:
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ANYEXT: // TODO Can G_ANYEXT end up here?
    return selectExt(I, MBB, MRI);
  case TargetOpcode::G_MERGE_VALUES:
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectMergeUnmerge(I, MBB, MRI);
  case TargetOpcode::G_PHI: {
    I.setDesc(TII.get(TargetOpcode::PHI));

    Register DstReg = I.getOperand(0).getReg();
    const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);
    return RBI.constrainGenericRegister(DstReg, *RC, MRI);
  }
  default:
    return false;
  }
}

namespace llvm {
InstructionSelector *
createM88kInstructionSelector(const M88kTargetMachine &TM,
                              const M88kSubtarget &Subtarget,
                              const M88kRegisterBankInfo &RBI) {
  return new M88kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
