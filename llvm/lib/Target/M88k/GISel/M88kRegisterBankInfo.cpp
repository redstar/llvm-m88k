//===-- M88kRegisterBankInfo.cpp -------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "MCTargetDesc/M88kMCTargetDesc.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/LegalizerHelper.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/CodeGen/TargetSubtargetInfo.h"
#include "llvm/CodeGenTypes/LowLevelType.h"
#include "llvm/IR/IntrinsicsM88k.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/ErrorHandling.h"
#include <cassert>

#define GET_TARGET_REGBANK_IMPL
#include "M88kGenRegisterBank.inc"

// This file will be TableGen'ed at some point.
#include "M88kGenRegisterBankInfo.def"

using namespace llvm;

M88kRegisterBankInfo::M88kRegisterBankInfo(const TargetRegisterInfo &TRI)
    : M88kGenRegisterBankInfo() {}

const RegisterBank &
M88kRegisterBankInfo::getRegBankFromRegClass(const TargetRegisterClass &RC,
                                             LLT Ty) const {
  switch (RC.getID()) {
  case M88k::GPRRegClassID:
  case M88k::GPR64RegClassID:
    return getRegBank(M88k::GRRegBankID);
  case M88k::XRRegClassID:
    return getRegBank(M88k::XRRegBankID);
  case M88k::CRRegClassID:
    return getRegBank(M88k::CRRegBankID);
  default:
    llvm_unreachable("Unexpected register class");
  }
}

const RegisterBankInfo::InstructionMapping &
M88kRegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  const unsigned Opc = MI.getOpcode();

  // Try the default logic for non-generic instructions that are either copies
  // or already have some operands assigned to banks.
  if ((Opc != TargetOpcode::COPY && !isPreISelGenericOpcode(Opc)) ||
      Opc == TargetOpcode::G_PHI) {
    const RegisterBankInfo::InstructionMapping &Mapping =
        getInstrMappingImpl(MI);
    if (Mapping.isValid())
      return Mapping;
  }

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();
  const M88kSubtarget &STI = MF.getSubtarget<M88kSubtarget>();
  const TargetRegisterInfo &TRI = *STI.getRegisterInfo();

  constexpr unsigned MaxNumOperands = 4;
  unsigned NumOperands = MI.getNumOperands();
  const ValueMapping *OperandsMapping = nullptr;
  unsigned MappingID = DefaultMappingID;

  // The register bank selection is not too complicated, because there is only 1
  // bank on the MC88100, and 2 banks on the MC88110. The 2nd bank for the
  // extemded registers is only chosen if it is required by the type of a
  // register. The basic cases to handle are:
  //  1. FP instructions with all operands having the same type
  //     Example: G_FADD
  //  2. FP instructions with operands of different type
  //     Example: G_FPEXTEND
  //  3. Instructions which may use different register banks
  //     Example: G_LOAD, G_INTRINSIC_TRUNC, COPY
  //  4. Instructions which only use the common register bank
  //     Example: G_OR
  // The 1st and 4th case are handled as the default case. The instructions for
  // the 2nd case are grouped together. Only the instructions of the 3rd case
  // require case-by-case handling.
  //
  // TODO The legalizer still uses s1 to represent a boolean flag. When this is
  //      gone then the code here can be simplified, too.

  switch (Opc) {
  case TargetOpcode::G_FCONSTANT: {
    LLT Ty = MRI.getType(MI.getOperand(0).getReg());
    if (Ty.getSizeInBits() != 64 && Ty.getSizeInBits() != 32)
      return getInvalidInstructionMapping(); // TODO Support 80 bit FP.
    PartialMappingIdx RBIdx = (Ty.getSizeInBits() == 64) ? PMI_GR64 : PMI_GR32;
    OperandsMapping = getOperandsMapping({getValueMapping(RBIdx), nullptr});
    break;
  }
  case TargetOpcode::G_FPTOSI:
  case TargetOpcode::G_FPTOUI: {
    LLT Ty = MRI.getType(MI.getOperand(1).getReg());
    if (Ty.getSizeInBits() != 64 && Ty.getSizeInBits() != 32)
      return getInvalidInstructionMapping(); // TODO Support 80 bit FP.
    PartialMappingIdx RBIdx = (Ty.getSizeInBits() == 64) ? PMI_GR64 : PMI_GR32;
    OperandsMapping =
        getOperandsMapping({getValueMapping(PMI_GR32), getValueMapping(RBIdx)});
    break;
  }
  case TargetOpcode::G_SITOFP:
  case TargetOpcode::G_UITOFP: {
    LLT Ty = MRI.getType(MI.getOperand(0).getReg());
    if (Ty.getSizeInBits() != 64 && Ty.getSizeInBits() != 32)
      return getInvalidInstructionMapping(); // TODO Support 80 bit FP.
    PartialMappingIdx RBIdx = (Ty.getSizeInBits() == 64) ? PMI_GR64 : PMI_GR32;
    OperandsMapping =
        getOperandsMapping({getValueMapping(RBIdx), getValueMapping(PMI_GR32)});
    break;
  }
  case TargetOpcode::G_TRUNC:
    OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ZEXT:
  case TargetOpcode::G_ANYEXT:
    OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::G_SEXT_INREG:
    OperandsMapping = getOperandsMapping(
        {getValueMapping(PMI_GR32), getValueMapping(PMI_GR32), nullptr});
    break;
  case TargetOpcode::G_SEXTLOAD:
  case TargetOpcode::G_ZEXTLOAD:
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    if (MRI.getType(MI.getOperand(0).getReg()).getSizeInBits() == 64)
      OperandsMapping = getOperandsMapping(
          {getValueMapping(PMI_GR64), getValueMapping(PMI_GR32)});
    else
      OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::G_BRCOND:
    OperandsMapping = getOperandsMapping({getValueMapping(PMI_GR32), nullptr});
    break;
  case TargetOpcode::G_BRJT:
    OperandsMapping = getOperandsMapping(
        {getValueMapping(PMI_GR32), nullptr, getValueMapping(PMI_GR32)});
    break;
  case TargetOpcode::G_ICMP:
    OperandsMapping = getOperandsMapping({getValueMapping(PMI_GR32), nullptr,
                                          getValueMapping(PMI_GR32),
                                          getValueMapping(PMI_GR32)});
    break;
  case TargetOpcode::G_SELECT:
    // TODO FP not handled.
    OperandsMapping = getOperandsMapping(
        {getValueMapping(PMI_GR32), getValueMapping(PMI_GR32),
         getValueMapping(PMI_GR32), getValueMapping(PMI_GR32)});
    break;
  case TargetOpcode::COPY: {
    Register DstReg = MI.getOperand(0).getReg();
    Register SrcReg = MI.getOperand(1).getReg();
    // Check if one of the register is not a generic register.
    if ((Register::isPhysicalRegister(DstReg) ||
         !MRI.getType(DstReg).isValid()) ||
        (Register::isPhysicalRegister(SrcReg) ||
         !MRI.getType(SrcReg).isValid())) {
      const RegisterBank *DstRB = getRegBank(DstReg, MRI, TRI);
      const RegisterBank *SrcRB = getRegBank(SrcReg, MRI, TRI);
      if (!DstRB)
        DstRB = SrcRB;
      else if (!SrcRB)
        SrcRB = DstRB;
      // If both RB are null that means both registers are generic.
      // We shouldn't be here.
      assert(DstRB && SrcRB && "Both RegBank were nullptr");
      TypeSize Size = getSizeInBits(DstReg, MRI, TRI);
      return getInstructionMapping(
          DefaultMappingID, copyCost(*DstRB, *SrcRB, Size),
          getCopyMapping(DstRB->getID(), SrcRB->getID(), Size),
          // We only care about the mapping of the destination.
          /*NumOperands*/ 1);
    }
    // Both registers are generic, use G_BITCAST.
    LLVM_FALLTHROUGH;
  }
  case TargetOpcode::G_BITCAST: {
    LLT DstTy = MRI.getType(MI.getOperand(0).getReg());
    LLT SrcTy = MRI.getType(MI.getOperand(1).getReg());
    TypeSize Size = DstTy.getSizeInBits();
    bool DstIsGPR = !DstTy.isVector() && DstTy.getSizeInBits() <= 64;
    bool SrcIsGPR = !SrcTy.isVector() && SrcTy.getSizeInBits() <= 64;
    const RegisterBank &DstRB = DstIsGPR ? M88k::GRRegBank : M88k::XRRegBank;
    const RegisterBank &SrcRB = SrcIsGPR ? M88k::GRRegBank : M88k::XRRegBank;
    return getInstructionMapping(
        DefaultMappingID, copyCost(DstRB, SrcRB, Size),
        getCopyMapping(DstRB.getID(), SrcRB.getID(), Size),
        // We only care about the mapping of the destination for COPY.
        /*NumOperands*/ Opc == TargetOpcode::G_BITCAST ? 2 : 1);
  }
  case TargetOpcode::G_INTRINSIC: {
    SmallVector<const RegisterBankInfo::ValueMapping *, 4> ValueMappings(
        NumOperands);
    for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
      auto &MO = MI.getOperand(Idx);
      if (!MO.isReg() || !MO.getReg())
        continue;
      ValueMappings[Idx] = getValueMapping(PMI_GR32);
    }
    OperandsMapping = getOperandsMapping(ValueMappings);
    break;
  }
    // Instructions with floating point operands in the same register bank.
  case TargetOpcode::G_FPEXT:
  case TargetOpcode::G_FPTRUNC: {
    SmallVector<PartialMappingIdx, MaxNumOperands> PartialMappings(NumOperands,
                                                                   PMI_None);
    bool RequiresXPR = false;
    for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
      auto &MO = MI.getOperand(Idx);
      if (!MO.isReg() || !MO.getReg())
        continue;
      LLT Ty = MRI.getType(MO.getReg());
      if (!Ty.isValid())
        continue;
      PartialMappingIdx RBIdx = PMI_None;
      switch (Ty.getSizeInBits()) {
      case 32:
        RBIdx = PMI_GR32;
        break;
      case 64:
        RBIdx = PMI_GR64;
        break;
      case 80:
        RBIdx = PMI_XR80;
        RequiresXPR = true;
        break;
      default:
        llvm_unreachable("Unsupport register size");
      }
      PartialMappings[Idx] = RBIdx;
    }
    SmallVector<const RegisterBankInfo::ValueMapping *, MaxNumOperands>
        ValueMappings(NumOperands);
    for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
      PartialMappingIdx RBIdx = PartialMappings[Idx];
      if (RequiresXPR) {
        if (RBIdx == PMI_GR32)
          RBIdx = PMI_XR32;
        else if (RBIdx == PMI_GR64)
          RBIdx = PMI_XR64;
      }
      ValueMappings[Idx] = getValueMapping(RBIdx);
    }
    OperandsMapping = getOperandsMapping(ValueMappings);
    break;
  }
    // Instructions using all the same register bank.
  default: {
    SmallVector<const RegisterBankInfo::ValueMapping *, MaxNumOperands>
        ValueMappings(NumOperands);
    for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
      auto &MO = MI.getOperand(Idx);
      if (!MO.isReg() || !MO.getReg())
        continue;
      LLT Ty = MRI.getType(MO.getReg());
      if (!Ty.isValid())
        continue;
      TypeSize TySz = Ty.getSizeInBits();
      assert((TySz == 32 || TySz == 64 || TySz == 80) &&
             "Unexpected type size");
      ValueMappings[Idx] = getValueMapping(
          TySz == 32 ? PMI_GR32 : (TySz == 64 ? PMI_GR64 : PMI_XR80));
    }
    OperandsMapping = getOperandsMapping(ValueMappings);
    break;
  }
  }

  return getInstructionMapping(MappingID, /*Cost=*/1, OperandsMapping,
                               NumOperands);
}

RegisterBankInfo::InstructionMappings
M88kRegisterBankInfo::getInstrAlternativeMappings(
    const MachineInstr &MI) const {
  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();
  const M88kSubtarget &STI = MF.getSubtarget<M88kSubtarget>();

  // The the MC88110 has alternative mappings.
  if (!STI.isMC88110())
    return RegisterBankInfo::getInstrAlternativeMappings(MI);

  const unsigned Opc = MI.getOpcode();
  switch (Opc) {
  case TargetOpcode::G_FADD:
  case TargetOpcode::G_FSUB:
  case TargetOpcode::G_FMUL:
  case TargetOpcode::G_FDIV: {
    unsigned NumOperands = MI.getNumOperands();
    assert(NumOperands <= 3 &&
           "This code is for instructions with 3 or less operands");
    unsigned TySz =
        MRI.getType(MI.getOperand(0).getReg()).getScalarSizeInBits();
    if (TySz == 80)
      break;
    PartialMappingIdx RBIdx1, RBIdx2;
    assert((TySz == 32 || TySz == 64) && "Unexpected type size");
    if (TySz == 32)
      RBIdx1 = PMI_GR32, RBIdx2 = PMI_XR32;
    else
      RBIdx1 = PMI_GR64, RBIdx2 = PMI_XR64;

    InstructionMappings AltMappings;
    AltMappings.push_back(&getInstructionMapping(
        /*ID*/ 1, /*Cost*/ 1, getValueMapping(RBIdx1), NumOperands));
    AltMappings.push_back(&getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1, getValueMapping(RBIdx2), NumOperands));
    return AltMappings;
  }
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE: {
    // TODO Add alternative mapping if the value is of floating point type.
    break;
  }
  case TargetOpcode::G_FPEXT:
  case TargetOpcode::G_FPTRUNC: {
    // TODO Add alternative mapping if the values are only 32/64 bit floats.
    break;
  }
  default:
    break;
  }
  return RegisterBankInfo::getInstrAlternativeMappings(MI);
}

void M88kRegisterBankInfo::applyMappingImpl(
    MachineIRBuilder &Builder, const OperandsMapper &OpdMapper) const {
  return applyDefaultMapping(OpdMapper);
}
